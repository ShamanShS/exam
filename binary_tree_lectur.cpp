#include <iostream>
 
using namespace std;
 
// работа с бинарными деревьями сортировки
class Tree
{
    // структура одного узла бинарного дерева (два потомка)
  struct Node
  {
        int info;
        Node* left; // ссылка на левый потомок - туда помещаются элементы, меньшие info
        Node* right; // ссылка на правый потомок - туда помещаются элементы, большие или равные info
        Node (int info)
        {
            this->info=info;
            left=right=NULL;   // создаются только листовые узлы дерева - узлы, у которых нет потомков
        }
  };
    // корень дерева
    Node* main_root;
    
    public:
    
    Tree();
     ~Tree();
    // нерекурсивный вариант функции добавления элемента в дерево
    void Add_1(int info);
    // функция-адаптер для рекурсивного варианта функции добавления элемента в дерево
    void Add_2(int info);
    // функция-адаптер для рекурсивного варианта функции печати элементов дерева
    void Print_2();
    
    private:
    // рекурсивные функции являются private-функциями, так как они по сути реализуют алгоритм и объект им нужен как хранилище данных
    // кроме того, параметры рекурсивной функции (ссылка на корень поддерева) фактически нарушают инкаплусяцию в случае видимости извне
    // рекурсивная функция добавления элемента в дерево (поддерево) с корнем root
    void Add_2(int info, Node*& root);
    // рекурсивная функция печати элементов дерева
    void Print_2(Node* root);
        // рекурсивная функция печати элементов дерева 
    void Destroy(Node* root);
};
 
// конструктор создает пустое дерево
Tree::Tree()
{
    main_root=NULL;
}
// деструктор является функцией-адаптером для вызова рекурсивной функции Destroy()
Tree::~Tree()
{
    Destroy(main_root);
}
// рекурсивная функция удаления дерево. 
// выход из рекурсии – не надо удалять пустое дерево
// если корень дерева есть, то сначала удаляем (рекурсивно) левое поддерево,
// затем правое поддерево, а затем удаляем корневой узел поддерева
void Tree::Destroy(Node* root)
{
    if (root==NULL) return;
    Destroy(root->left);
    Destroy(root->right);
    delete root;
}
 
//функция-адаптер для рекурсивного варианта функции печати элементов дерева
void Tree::Print_2()
{
    // если дерево пустое, печатаем сообщение
    if (main_root==NULL)
        cout<<"Дерево пусто"<<endl;
    else
        // для непустого дерева вызываем рекурсивную функцию для всего дерева (передаем корень всего дерева)
        Print_2(main_root);
}
 
// рекурсивная функция печати элементов поддерева с корнем root (обход ЛКП) 
void Tree::Print_2(Node* root)
{
    // явный случай - пустое дерево не печатаем
    if (root==NULL) return;
    // сначала печатаем левое поддерево
    Print_2(root->left);
    // печатаем значение в корне поддерева
    cout<<(root->info)<<" ";
    // печатаем правое поддерево
    Print_2(root->right);
}
 
// функция-адаптер для алгоритма рекурсивного добавления элемента в дерево
void Tree::Add_2(int info)
{
    // нерекурсивный вызов
    Add_2(info, main_root);
}
 
// рекурсивная функция добавления элемента в поддерево с корнем root  (передается по ссылке, чтобы можно было новый узел сохранить)
void Tree::Add_2(int info, Node*& root)
{
    // если поддерево пустое, создаем единственный узел (адрес сохранится в переменной, ссылка на которую передана в качестве параметра)
    if(root==NULL)
    {
        root = new Node(info); return;
    }
    // если значение должно быть в левом поддереве
    if(root->info > info)
        // добавляем значение в левое поддерево
        Add_2(info, root->left);
    else
        // добавляем значение в правое поддерево
        Add_2(info, root->right);
}
 
// нерекурсивный вариант функции добавления элемента в дерево 
void Tree::Add_1(int info)
{
    // в пустое дерево добавляется единственный узел
    if(main_root==NULL)
    {
        main_root = new Node(info); return;
    }
    //если дерево не пустое, требуется найти место встави, начиная с корня, пройдя по одной ветви дерева 
    Node* cur=main_root;
    // движение по дереву будем проводить до получения места вставки - количество шагов в этом случае неизвестно
    while(true)
    {
        if(cur->info > info)
            // добавление производится в левое поддерево
            if(cur->left!=NULL)
                // если левое поддерево не пусто, то сдвигаемся на корень левого поддерева
                cur=cur->left;
            else
            {
                // если левое поддерево пусто, найдено место вставки
                // создается новый элемент и подцепляется в виде левого потомка
                cur->left=new Node(info); return;
            }
        else
            // добавление производится в правое поддерево
            if(cur->right!=NULL)
                // если правое поддерево не пусто, то сдвигаемся на корень правого поддерева
                cur=cur->right;
            else
            {
                // если правое поддерево пусто, найдено место вставки
                // создается новый элемент и подцепляется в виде правого потомка
                cur->right=new Node(info); return;
            }
    }
}
 
 
int main()
{
    Tree tree;
    int a[]={7,3,6,8,1,2,4,5,10};
    for(int i=0;i<9; i++)
        tree.Add_2(a[i]);
    tree.Print_2();
    cout<<endl;
   
    return 0;
}
 


