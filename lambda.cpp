#include <iostream>
#include <vector>
 
using namespace std;
 
// класс-функтор
// функтор - это класс, в котором переопределен оператор (). Таким образом, объект класса можно будет трактовать как функцию
// использование объекта класса позволяет сохранять состояние (иметь внутренние переменные, которые могут хранить промежуточные результаты вычислений при повторном вызове функций)
// пример функтора - суммирование параметров функции при разоичных вызовах функции
class A 
{
    int a;
    public:
    A(){a=0;};
    void operator()(int x){a+=x;};
    int get(){return a;}
    
};
 
int main()
{
    // функция поиска максимума из 3 чисел
    // люмбда-выражение позволяет в виде переменной сохранять информацию о функции
    // переменную можно будет передавать как параметр в функцию, возвращать из функции, менять на другое люмбда-выражение (функцию)
    // определение связано с указанием параметров в круглых скобках, указанием тела функции в фигурных скобках
    // квадратные скобки определяют разрешения на использование переменных, которых видны во внешнем окружении
    
    // классические концепции функционального программирования запрещают использование операторов в теле функции
    // даже цикл можно представить в виде рекурсивных процессов. 
    // поэтому желательно, чтобы функция максимально напоминала вычисление выражения в математическом смысле
    auto f_max = [](int a, int b, int c){
        return a>b? (a>c?a:c):(b>c?b:c);
    };
 
    cout<<f_max(5,5,5)<<endl;
    
    // получение всех делителей целого числа
    // в данном примере два люмбда-выражения формируют суперпозицию функций
    auto f_isDel=[](int a, int b){return a%b==0;};
    
    // предыдущее люмбда-выражение необходимо для текущего, разрешаем ее использовать в контексте окружения
    auto f_allDel=[f_isDel](int a)
    {
        vector<int> res;
        res.push_back(1);
        for(int i=2;i<=a/2;i++)
            if(f_isDel(a,i)) 
                res.push_back(i);
        res.push_back(a);
        return res;
    };
    
    vector<int> res=f_allDel(11937);
    for(int i=0;i<res.size();i++)
        cout<<res[i]<<" ";
    cout<<endl;
 
    // если из окружения разрешается использовать переменную, в которую будем записывать результат (в данном случае список res),
    // необходимо указать перед этой переменной символ & для подчеркивания факта, что можно не просто использовать переменную, но и менять ее состояние
    auto f_allDel1=[&res,f_isDel](int a)
    {
        res.clear();
        res.push_back(1);
        for(int i=2;i<=a/2;i++)
            if(f_isDel(a,i)) 
                res.push_back(i);
        res.push_back(a);
    };
    
    f_allDel1(11937);
    for(int i=0;i<res.size();i++)
        cout<<res[i]<<" ";
    cout<<endl;
    
    // функция слияния двух отсортированных массивов
    auto f_isEnd=[](vector<int> v,int i)
    {
        return v.size()==i;  
    };
    
    int i,j;
    auto f_getMin=[&i,&j,f_isEnd](vector<int> v1, vector<int> v2)
    {
        return (!f_isEnd(v1,i) && !f_isEnd(v2,j))?(v1[i]<v2[j]?v1[i++]:v2[j++]):f_isEnd(v1,i)?v2[j++]:v1[i++];  
    };
    auto f_merge=[f_getMin, f_isEnd,&i,&j](vector<int> v1, vector<int> v2)
    {
        i=0; j=0;
        vector<int> res;
        while(!f_isEnd(v1,i) || !f_isEnd(v2,j))
            res.push_back(f_getMin(v1,v2));
        return res;
    };
 
    vector<int> v1={2,7,10,15,18};
    vector<int> v2={8,13,14,20,25,28};
    res.clear();
    res=f_merge(v1,v2);
    
    for(int i=0;i<res.size();i++)
        cout<<res[i]<<" ";
    cout<<endl;
    
    A a;
    for(int i=0;i<5;i++)
        a(i);
    cout<<a.get()<<endl;
 
    return 0;
}

 