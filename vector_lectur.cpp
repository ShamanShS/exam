/*
Создание класса n-мерного вектора.
 
Цели - обратить внимание на особенности реализации классов, которым требуется выделение памяти,
переопределение (перегрузка) операций и особенности их применения
 
*/
#include <iostream>
 
using namespace std;
 
class Vector 
{
    // так как размер вектора известен, то инкапсулируется массив
    int n;     // размерность вектора
    double* a; // адрес памяти массива элементов
    
    public:
    // конструкторы
    Vector(int n);
    Vector(int n, double* a);
    // конструктор копирования
    Vector (const Vector& ob);
    ~Vector();
    // переопределение оператора присваивания
    Vector& operator=(Vector ob);
    
    /*Vector Summa(Vector ob);
    Vector Multiply(double b);
    double Multiply(Vector ob);
    */
    void Input();
    void Print();
    
    // перегрузка операций
    Vector operator+(Vector ob);
    Vector operator*(double b);
    double operator*(Vector ob);
    
    // перегрузка операций ввода и вывода внешними функциями
    // дружественность - инструмент, позволяющий отдельным функциям/классам иметь доступ к private-элементам разрабатываемого класса
    friend istream& operator>>(istream&in, Vector& ob);
    friend ostream& operator<<(ostream&out, Vector ob);
};
 
 
/*
Перегрузка операций ввода и вывода осуществляется только внешними функциями, так как первым операндом
должен являться оператор потока ввода или вывода.
Возвращаемое значение этих операций - ссылка на объект потока ввода или вывода, чтобы иметь возможность в одной операции
вводить/выводить несколько значений, например,
(cout<<a)<<b;
Параметры обусловлены контекстом вызова - первый параметр - поток ввода или вывода, второй - объект вектора/
 
Потоки ввода и вывода передаются и возвращаются по ссылке, чтобы не создавалась копия сложного библиотечного объекта.
 
Для доступа к данным объекта-вектора эти функции объявляются в классе как дружественные, т.е. им разрешен доступ к 
private-элементам класса Vector.
 
Операция ввода получает объект вектора по ссылке, чтобы можно было вводить в него значения.
*/
 
istream& operator>>(istream&in, Vector& ob)
{
    for(int i=0;i<ob.n;i++)
        in>>ob.a[i];
    return in;
}
 
ostream& operator<<(ostream&out, Vector ob)
{
    out<<"(";
    for(int i=0;i<ob.n-1;i++)
        out<<ob.a[i]<<",";
    out<<ob.a[ob.n-1]<<")"<<endl;
    return out;
}
 
/*
Если в классе предусмотрена работа с памятью, то обязательный набор - 
конструктор под наиболее частый вариант инициализации (без параметров или с параметрами), 
конструктор копирования, деструктор, перегруженный оператор присваивания.
 
Это обеспечит корректное автоматическое создание и уничтожение объектов.
Автоматически объект может создаваться при передаче объекта в качестве параметра в функцию (по умолчанию параметры передаются по значению),
при возвращении объекта из функции.
Уничтожение объекта осуществляется автоматически при выходе объекта из области его видимости. Явно вызывать деструктор нельзя.
 
Любой конструктор должен проверять целостность создаваемого объекта. Если входные данные не соответствуют целостному состоянию,
должно быть сгенерировано исключение, которое позволит завершить конструктор аварийно без создания объекта.
*/
Vector::Vector(int n)
{
    if(n<=0) throw 1;
    
    this->n=n;
    a=new double[n];
    for(int i=0;i<n;i++)
        a[i]=0;
}
 
Vector::Vector(int n, double* a)
{
    if(n<=0) throw 1;
    this->n=n;
    this->a=new double[n];
    for(int i=0;i<n;i++)
        this->a[i]=a[i];
}
 
/*
Конструктор копирования обязателен, если объект может передаваться в функцию в качестве параметра и/или возвращаться функцией.
Отсутствие конструктора копирования приводит к генерации конструктора копирования по умолчанию, который скопирует адрес памяти,
а не ее содержание. Поэтому два объекта (реальный и локальный для функции) будут хранить адреса одной и той же памяти и при 
уничтожении локального объекта эта память будет освобождена. Таким образом, будет нарушена целостность реального объекта.
*/
Vector::Vector(const Vector& ob)
{
    n=ob.n;
    a=new double[n];
    for(int i=0;i<n;i++)
        a[i]=ob.a[i];
}
 
Vector::~Vector()
{
    delete [] a;
}
 
// может потребоваться переписывать существующий уже объект. Тогда вызывается оператор присваивания
Vector& Vector::operator=(Vector ob)
{
    // при присваивании размеры объектов могут не совпадать, поэтому присваиваемый объект должен
    // подстроиться под размер присваиваемого объекта
    if(n!=ob.n)
    {
        delete [] a;
        n=ob.n;
        a=new double[n];
    }
    for(int i=0;i<n;i++)
        a[i]=ob.a[i];
    
    // требуется для возможности делать цепочку присваивания: a=b=c;    
    return *this;
}
    
void Vector::Input()
{
    for(int i=0;i<n;i++)
        cin>>a[i];
}
 
void Vector::Print()
{
    cout<<"(";
    for(int i=0;i<n-1;i++)
        cout<<a[i]<<",";
    cout<<a[n-1]<<")"<<endl;
}
 
/*
При перегрузке операций необходимо учитывать количество операндов у операций и интуитивный прототип.
Поэтому при невозможности выполнения операции (в данном случае при несовпадении размеров суммируемых векторов),
единственный корректный вариант - аварийное завершение оператора с помощью генерации исключительной ситуации.
 
При перегрузке операций методом класса для унарных операций не требуется передача параметров, для бинарных операций
требуется передача одного объекта (второго операнда).
Первый операнд должен быть объектом, в контексте которого вызывается метод.
 
*/
Vector Vector::operator+(Vector ob)
{
    if(n!=ob.n)
        throw 2;
    Vector res(n);
    for(int i=0;i<n;i++)
        res.a[i]=a[i]+ob.a[i];
    return res;
}
 
Vector Vector::operator*(double b)
{
    Vector res(n);
    for(int i=0;i<n;i++)
        res.a[i]=a[i]*b;
    return res;
}
 
double Vector::operator*(Vector ob)
{
    if(n!=ob.n)
        throw 2;
    double res=0;
    for(int i=0;i<n;i++)
        res+=a[i]*ob.a[i];
    return res;
    
}
 
// перегрузка операции внешней функцией - единственный вариант, когда первый оперант имеет стандартный или библиотечный тип данных,
// так как вызов метода в контексте объекта уже невозможен
// Часто перегружают две версии операции с операндами разных типов данных, подстраиваясь под возможный порядок вызова оператора пользователем. 
// Одна версия может просто вызывать другую - не надо повторять алгоритм дважды.
Vector operator*(double b, Vector ob)
{
    return ob*b;
}
 
int main()
{
   try
   {
       Vector a(5), b(5);
       cin>>a>>b;
       cout<<a<<b;
       Vector c=a+b;
       cout<<c;
       a=c+b;
       cout<<a;
       a=b*2; // a=b.operator*(2);
       //a=2*b; // a=2.operator*(b);
       cout<<a;
       cout<<(a*b)<<endl;
      // Vector d=c+b;
       //d.Print();
   }
    catch(int i)
    {
        switch(i)
        {
            case 1: cout<<"Ошибка размерности при создании объекта"<<endl; break;
            case 2: cout<<"Недопустимые операнды у операции"<<endl;
        }
    }
    return 0;
}


