#include <iostream>
#include <climits>
#include <queue>
#include <stack>
#include <list>
#include <vector>
 
using namespace std;
 
// работа с графами, построение, поиск кратчайших путей
// обход вершин графа
 
class Graph
{
    int n; // количество вершин
    int m; // количество ребер
    // хранение графа осуществляется с помощью матрицы смежности
    int** a; // матрица смежности графа - элемент хранит информацию о смежности вершин
    // матрица длин кратчайших путей - T[i][j] -длина кратчайшего пути из вершины i в вершину j
    int** T;
    // матрица номеров первых вершин на кратчайших путях - 
    // H[i][j] - номер вершины, в которую нужно идти из вершины i, если нужно попасть в вершину j
    int** H;

    public:
    // служебные функции построения графа
    Graph(int n, int m);
    ~Graph();
    // ввод графа осуществляется с помощью массива ребер
    void Input();
    void Print();
    
    // обход вершин графа в ширину
    list<int> PathOnWidth(int v);
    // обход вершин графа в глубину
    list<int> PathOnDepth(int v);
    
    // создание графа для тестирования
    void InputTest();

   // метод для получения пути между двумя заданными вершинами begin и end.
    // список вершин пути возвращается как результат функции
    // в параметр len заносится длина найденного пути
    list<int> ShortestPath(int begin, int end, int& len);

    // поиск кратчайшего пути между двумя заданными вершинами (алгоритм Дейекстра)
    list<int> ShortestPath_D(int begin, int end, int& len);
    private:
    // алгоритм поиска кратчайших путей между всеми парами вершин (Алгоритм Флойда)
    void Floyd();
};

 // поиск кратчайшего пути между двумя заданными вершинами (алгоритм Дейекстра)
list<int> Graph::ShortestPath_D(int begin, int end, int& len)
{
    // массив помеченных вершин
    vector<bool> labels;
    // массив длин найденных кратчайших путей (из вершины begin во все остальные)
    vector<int> lens;
    // массив хранит номер вершины-предшественника концевой вершины на кратчайшем пути из вершины begin в i-ую
    vector<int> prevs;
    
    // начальная инициализация массивов
    for(int i=0;i<n;i++)
    {
        // вершины пока не просмотрены
        labels.push_back(false);
        // длины кратчайших путей равны бесконечности
        lens.push_back(INT_MAX);
        // так как не найдены пути, вершины-предшественника для концевой вершины пока нет
        prevs.push_back(-1);
    }
    
    // текущая вершина - вершина начала пути 
    int v=begin-1;
    labels[v]=true;
    lens[v]=0;
    
    // флаг успешности нахождения кратчайшего пути
    bool f=false;
    // осуществляем пересчет кратчайших путей - количество итераций неизвестно заранее
    while(true)
    {
        // просмотриваем все непросмотренные смежные вершины с v, чтобы, возможно,
        // скорректировать длины кратчайших путей через них        
        for(int i=0;i<n;i++)
            // вершина i смежна вершине v
            if(v!=i && a[v][i]!=INT_MAX)
                // вершина должна быть непомеченной
                if(!labels[i])
                    // проверка того, что путь в i-ую вершину через вершину v короче уже найденного
                    if(lens[i] > lens[v]+a[v][i])
                    {
                        // корректируем длины кратчайших путей и вершину-предшественника
                        lens[i]= lens[v]+a[v][i];
                        prevs[i]=v;
                    }
        // поиск вершины, куда следует пройти на следующей итерации
        // выбираем вершину с минимальной длиной пути в нее среди непомеченных вершин
        int min=INT_MAX, imin=-1;
        for(int i=0;i<n;i++)
            if(!labels[i] && lens[i]<min)
            {
                min=lens[i];
                imin=i;
            }
        // если минимум не изменился, то пути не найдено - выход из цикла
        if(imin==-1)
            break;
        // дошли до конечной вершины пути - кратчайший путь найден - выход из цикла
        if(imin==end-1)
        {
            f=true; // путь найден - установка флага успешности выполнения операции
            break;
        }
        // переход в вершину, которой соответствует минимальный найденный на текущий момент путь
        v=imin;
        // делаем пометку, что эта вершина уже пройдена
        labels[v]=true;
    }
    // формирование результата
    if(f)
    {
        // длина найденного кратчайшего пути помещается в параметр
        len=lens[end-1];
        // путь раскручиваем с конца, так как массив prevs хранит вершины-предшественники для всех концевых вершин
        list<int> path;
        // для получения обратного порядка используем стек
        stack<int> s;
        // текущая вершина - конец пути
        s.push(end); // помещаем ее в стек
        v=end-1;
        // пока не достигнем начальной вершины пути, переходим к вершине-предшественнику
        // и помещаем новую текущую вершину в стек
        while(v!=begin-1)
        {
            v=prevs[v];
            s.push(v+1);
        }
        //переносим результаты в список-результат для получения маршрута
        while(!s.empty())
        {
            path.push_back(s.top()); s.pop();
        }
        return path;
    }
    // если пути не найдено, генерируем исключение
    throw 1;
}
   

// алгоритм поиска кратчайших путей между всеми парами вершин (Алгоритм Флойда)
void Graph::Floyd()
{
    // начальная инициализация
    for(int i=0; i<n;i++)
        for(int j=0;j<n; j++)
        {
            // путь между i и j вершинами есть, когда есть ребро i->j
            T[i][j]=a[i][j];
            H[i][j] = a[i][j]==INT_MAX? -1: j;
        }
    // делаем попытки вставить вершину i во все маршруты j->k
    for(int i=0;i<n;i++)  // вершина, которую включаем в середину пути
        // перебор маршрутов
        for(int j=0;j<n;j++) // начало маршрута
            for(int k=0; k<n;k++)  // конец маршрута
                // все вершины должны быть разными
                // не нужны маршруты типа i->i
                if(i!=j && i!=k && j!=k)
                    // пробуем построить маршрут из j в к через вершину i
                    // если существуют оба маршрута j->i и i->k (их длины - не бесконечности),
                    // то, возможно через вершину i проехать быстрее
                    if(T[j][i]!=INT_MAX && T[i][k]!=INT_MAX)
                        // сравниваем длины уже имеющегося пути (T[j][k]) и суммарную длину пути, если
                        // сначала едем в i вершину, а уж потом в k (T[j][i]+T[i][k])
                        if(T[j][k]>T[j][i]+T[i][k])
                        {
                            // меняем данные о крайтчайшем пути
                            T[j][k]=T[j][i]+T[i][k];
                            // при таком пути первая вершина на пути из j в k будет той же,
                            // что и первая вершина из j в i (так как сначала едем в i)
                            H[j][k]=H[j][i];
                        }
}
 
// получение кратчайшего пути
list<int> Graph::ShortestPath(int begin, int end, int& len)
{
    list<int> result;
    // длина хранится в матрице длин кратчайших путей
    len=T[begin-1][end-1];
    // сам путь строится из матрицы H
    // v - текущая вершина. Вначале она совпадает с начальной вершиной пути
    int v=begin-1;
    // пока не достигли конца пути (вершина end при нумерации с 1)
    while(v!=end-1)
    {
        // заносим текущую вершину в список 
        result.push_back(v);
        // сдвигаем текущую вершину на следующую за ней при пути в вершину end
        v=H[v][end-1];
    }
    // конечную вершину тоже записываем в список результата
    result.push_back(v);
    return result;
}

// обход вершин графа в ширину
list<int> Graph::PathOnWidth(int v)
{
    // массив для пометок просмотренных вершин
    vector<bool> labels;
    for(int i=0;i<n;i++)
        labels.push_back(false);
    
    // очередь для определения последовательности обработки
    queue<int> q;
    // список для формирования результата
    list<int> res;
    // v - начальная вершина, с которой будет начинаться обход
    // помечаем ее как просмотренную и помещаем в очередь
    q.push(v); labels[v]=true;
    // процесс завершается, когда в очереди ничего не останется
    while(!q.empty())
    {
        // извлекаем очередную вершину для обработки
        v=q.front(); q.pop();
        // добавляем эту вершину в список-результат - корректируем на 1 номер, чтобы на вывод нумерация была не с 0
        res.push_back(v+1);
        // все непросмотренные смежные вершины с текущей помещаем в очередь и помечаем
        for(int i=0;i<n;i++)
            // проверка на то, что вершины не помечены, и что между текущей вершиной v и вершиной i нет связи
            if(!labels[i] && i!=v && a[v][i]!=INT_MAX)
            {
                q.push(i); labels[i]=true;
            }
    }
    return res;
}
 
// обход вершин графа в глубину
list<int> Graph::PathOnDepth(int v)
{
    // массив для пометок просмотренных вершин
    vector<bool> labels;
    for(int i=0;i<n;i++)
        labels.push_back(false);
    
    // стек для определения последовательности обработки
    stack<int> s;
    // список для формирования результата
    list<int> res;
    // v - начальная вершина, с которой будет начинаться обход
    // помечаем ее как просмотренную и помещаем в стек
    s.push(v); labels[v]=true;
    // процесс завершается, когда в стеке ничего не останется
    while(!s.empty())
    {
        // извлекаем очередную вершину для обработки
        v=s.top(); s.pop();
        // добавляем эту вершину в список-результат - корректируем на 1 номер, чтобы на вывод нумерация была не с 0
        res.push_back(v+1);
        // все непросмотренные смежные вершины с текущей помещаем в стек и помечаем
        for(int i=0;i<n;i++)
            // проверка на то, что вершины не помечены, и что между текущей вершиной v и вершиной i нет связи
            if(!labels[i] && i!=v && a[v][i]!=INT_MAX)
            {
                s.push(i); labels[i]=true;
            }
    }
    return res;
}
 
void Graph::InputTest()
{
    a[0][1]=4; a[0][2]=2;
    a[1][4]=3;a[2][0]=2;
    a[2][3]=2;a[2][4]=4;
    a[3][1]=1; a[3][5]=0;
    a[4][2]=4; a[4][5]=3;
    a[5][0]=10; a[5][3]=0; a[5][4]=3;
   Floyd();
}
 
// конструктор - основная часть - создание матрицы смежности
Graph::Graph(int n, int m)
{
    if(m<=0 || n<=0) throw 1;
    this->m=m; this->n=n;
    a=new int*[n];
    for(int i=0;i<n;i++)
    {
        a[i]=new int[n];
        // инициализация бесконечными значениями
        // кроме главной диагонали - на ней должны стоять 0, так как из вершины не
        // надо перемещаться в нее же саму
        for(int j=0;j<n;j++)
            a[i][j]=i==j?0:INT_MAX;
    }

// создание матриц для хранения кратчайших путей
    T=new int*[n];
    H=new int*[n];
    for(int i=0;i<n;i++)
    {
        T[i]=new int[n];
        H[i]=new int[n];
    }
}
 
//деструктор
Graph::~Graph()
{
    for(int i=n-1;i>=0;i--)
    {
        delete [] T[i];
        delete [] H[i];
        delete [] a[i];
    }
    delete [] a;
    delete [] T;
    delete [] H;
}
 
// ввод информации о графе будем осуществлять с помощью воода массива ребер
void Graph::Input()
{
    for(int i=0;i<m;i++)
    {
        // запрашиваем информацию о каждом ребре и устанавливаем
        // соответствующие элементы матрицы смежности
        int begin, end, len;
        int choice;
        cout<<"Введите "<<(i+1)<<" ребро:"<<endl;
        cout<<"начало:"; cin>>begin;
        cout<<"конец:"; cin>>end;
        cout<<"Длина:"; cin>>len;
        cout<<"Ориентировано (да - 1,нет - 0):"; cin>>choice;
        // задание значения длины дуги (однонаправленность) или ребра (если нет однонаправленности) в матрицу
        a[begin-1][end-1]=len;
        if(choice==0)
            a[end-1][begin-1]=len;
    }
   Floyd();
}
 
// вывод матрицы смежности
void Graph::Print()
{
    cout<<"Граф:"<<endl;
    for(int i=0;i<n;i++)
    {
        for(int j=0;j<n;j++)
            if(a[i][j]!=INT_MAX)
                cout<<a[i][j]<<"\t";
            else
                cout<<"-"<<"\t";
        cout<<endl;
    }
    cout<<endl;
}
 
int main()
{
    Graph gr(6,9);
    gr.InputTest();
    gr.Print();
    // обход графа в ширину
    list<int> path=gr.PathOnWidth(3);
    
    //  просмотр пути обхода графа
    // класс-итератор определяет способ просмотра списка наподобие индекса или указателя
    // метод begin() получает итератор первого элемента
    list<int>::iterator p=path.begin();
    // итератор нужно сдвигать до достижения итератора конца, который получается с помощью метода end() 
    while(p!=path.end())
    {
        // операция * позволяет получить информацию из элемента списка, на который указывает итератор
        cout<<(*p)<<" ";
        p++;
    }
    cout<<endl;
     // обход графа в глубину
    path=gr.PathOnDepth(3);
    
    //  просмотр пути обхода графа
    // класс-итератор определяет способ просмотра списка наподобие индекса или указателя
    // метод begin() получает итератор первого элемента
    p=path.begin();
    // итератор нужно сдвигать до достижения итератора конца, который получается с помощью метода end() 
    while(p!=path.end())
    {
        // операция * позволяет получить информацию из элемента списка, на который указывает итератор
        cout<<(*p)<<" ";
        p++;
    }
    return 0;
}

